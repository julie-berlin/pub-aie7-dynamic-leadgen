"""Survey API endpoints for frontend interaction."""

from fastapi import APIRouter, HTTPException, Request, Header
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import logging
from datetime import datetime

# Import consolidated Pydantic models
from ...pydantic_models import (
    StartSessionRequest,
    StartSessionResponse,
    SubmitResponsesRequest,
    StepResponse,
    CompletionResponse,
    SessionStatusResponse,
    AbandonSessionRequest,
    ErrorResponse,
    QuestionData,
    SurveyGraphState,
    create_initial_state,
    LeadStatus,
    CompletionType
)
from ..graphs.survey_graph_v2 import survey_graph_v2

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/survey", tags=["survey"])


class AbandonResponse(BaseModel):
    """Simple response model for abandonment endpoint."""
    status: str
    message: str


@router.post("/start", response_model=StartSessionResponse)
async def start_session(
    request: StartSessionRequest,
    referer: Optional[str] = Header(None),
    user_agent: Optional[str] = Header(None),
    x_forwarded_for: Optional[str] = Header(None)
):
    """
    Start a new survey session with tracking parameters.
    
    This endpoint:
    1. Captures UTM parameters and tracking data
    2. Initializes the survey flow
    3. Returns the first set of questions
    """
    try:
        # Prepare initial state with tracking data
        initial_state = {
            'metadata': {
                'form_id': request.form_id,
                'client_id': request.client_id,
                'utm_source': request.utm_source,
                'utm_medium': request.utm_medium,
                'utm_campaign': request.utm_campaign,
                'utm_content': request.utm_content,
                'utm_term': request.utm_term,
                'landing_page': request.landing_page,
                'referrer': referer,
                'user_agent': user_agent,
                'ip_address': x_forwarded_for or 'unknown'
            }
        }
        
        # Run the graph to initialize and get first questions
        result = await survey_graph_v2.ainvoke(initial_state)
        
        # Extract frontend response
        frontend_data = result.get('frontend_response', {})
        
        return StartSessionResponse(
            session_id=frontend_data.get('session_id'),
            questions=frontend_data.get('questions', []),
            headline=frontend_data.get('headline', 'Welcome!'),
            motivation=frontend_data.get('motivation', 'Let\'s get started.'),
            step=1
        )
        
    except Exception as e:
        logger.error(f"Failed to start session: {e}")
        raise HTTPException(status_code=500, detail="Failed to initialize survey session")


@router.post("/step", response_model=StepResponse)
async def submit_and_continue(
    request: SubmitResponsesRequest
):
    """
    Submit responses and get the next step.
    
    This endpoint:
    1. Saves the submitted responses immediately
    2. Processes responses through supervisors
    3. Returns next questions or completion message
    """
    try:
        # Prepare state with responses to process
        state_update = {
            'core': {'session_id': request.session_id},
            'pending_responses': request.responses
        }
        
        # Run the graph starting from response processing
        result = await survey_graph_v2.ainvoke(
            state_update,
            {"recursion_limit": 25}
        )
        
        # Check if survey is complete
        core = result.get('core', {})
        completed = core.get('completed', False)
        
        # Get frontend response data
        frontend_data = result.get('frontend_response', {})
        
        response = StepResponse(
            session_id=request.session_id,
            step=frontend_data.get('step', 1),
            questions=frontend_data.get('questions', []),
            headline=frontend_data.get('headline', ''),
            motivation=frontend_data.get('motivation', ''),
            progress=frontend_data.get('progress', {}),
            completed=completed
        )
        
        # Add completion message if done - now uses Phase 4 conditional completion
        if completed:
            # The completion message is now generated by our conditional completion nodes
            response.completion_message = result.get('completion_message', 
                'Thank you for your time and interest.')
        
        return response
        
    except Exception as e:
        logger.error(f"Failed to process step: {e}")
        raise HTTPException(status_code=500, detail="Failed to process survey step")


@router.post("/abandon/{session_id}", response_model=AbandonResponse)
async def mark_abandoned(session_id: str):
    """
    Mark a session as abandoned.
    
    Called by frontend when user leaves or times out.
    """
    try:
        # Update session as abandoned
        state_update = {
            'core': {
                'session_id': session_id,
                'completed': True
            },
            'engagement': {
                'abandonment_status': 'abandoned',
                'abandonment_risk': 1.0
            }
        }
        
        # Run abandonment flow
        await survey_graph_v2.ainvoke(state_update)
        
        return AbandonResponse(
            status="success", 
            message="Session marked as abandoned"
        )
        
    except Exception as e:
        logger.error(f"Failed to mark session as abandoned: {e}")
        raise HTTPException(status_code=500, detail="Failed to update session")


@router.get("/status/{session_id}", response_model=SessionStatusResponse)
async def get_session_status(session_id: str):
    """
    Get the current status of a survey session.
    
    Useful for resuming sessions or checking completion.
    """
    try:
        # Load session from database
        from ..database import db
        
        session_data = db.get_lead_session(session_id)
        if not session_data:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Get additional data
        responses = db.get_session_responses(session_id)
        
        return SessionStatusResponse(
            session_id=session_id,
            status="completed" if session_data.get('completed', False) else "active",
            step=session_data.get('step', 0),
            completed=session_data.get('completed', False),
            lead_status=session_data.get('lead_status', 'unknown'),
            abandonment_risk=float(session_data.get('abandonment_risk', 0.3)),
            abandonment_status=session_data.get('abandonment_status', 'active'),
            form_id=session_data.get('form_id', ''),
            started_at=session_data.get('started_at'),
            completed_at=session_data.get('completed_at'),
            response_count=len(responses),
            completion_type=session_data.get('completion_type')
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get session status: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve session status")


@router.get("/db-health")
async def database_health_check():
    """
    Database-specific health check for the survey system.
    
    Returns database connectivity and survey-specific table status.
    """
    try:
        from ..database import db
        import json
        
        # Test basic database connection
        db_connected = db.test_connection()
        
        # Test survey-specific functionality
        forms_accessible = False
        sample_form = None
        try:
            # Try to load a sample form
            sample_form = db.get_form("dogwalk_demo_form") 
            forms_accessible = sample_form is not None
        except Exception:
            pass
        
        return {
            "database_connected": db_connected,
            "forms_table_accessible": forms_accessible,
            "sample_form_loaded": sample_form is not None,
            "timestamp": datetime.now().isoformat(),
            "status": "healthy" if (db_connected and forms_accessible) else "degraded"
        }
        
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        return {
            "database_connected": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat(),
            "status": "unhealthy"
        }


@router.get("/forms/{form_id}/validate")
async def validate_form(form_id: str):
    """
    Validate that a form exists and is properly configured.
    
    Useful for frontend validation before starting a survey.
    """
    try:
        from ..database import db
        from ..tools import load_questions, load_client_info
        import json
        
        # Check if form exists
        form = db.get_form(form_id)
        if not form:
            raise HTTPException(status_code=404, detail=f"Form {form_id} not found")
        
        # Check if questions exist
        questions_json = load_questions.invoke({'form_id': form_id})
        questions = json.loads(questions_json) if questions_json else []
        
        # Check if client info exists
        client_json = load_client_info.invoke({'form_id': form_id})
        client_info = json.loads(client_json) if client_json else {}
        
        return {
            "form_id": form_id,
            "valid": True,
            "form_exists": bool(form),
            "questions_count": len(questions),
            "client_configured": bool(client_info.get('client')),
            "form_title": form.get('title', ''),
            "form_description": form.get('description', '')
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to validate form {form_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to validate form")